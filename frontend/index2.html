<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NXL - Particle Dispersion</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Basic CSS Reset and Styling */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #000000;
        }
        /* Canvas Styling */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #grid-canvas {
            z-index: 1;
        }
        #three-canvas {
            z-index: 2;
            opacity: 0;
            animation: fadeInCanvas 1.5s ease-out forwards 2s; /* Start after grid anim */
        }
        #particle-canvas {
            z-index: 3;
            cursor: none; /* Hide default cursor for a cleaner look */
            opacity: 0;
            animation: fadeInCanvas 1.5s ease-out forwards 2.5s; /* Delay to start after 3D canvas */
        }
        /* Custom Cursor Styling */
        .custom-cursor {
            position: fixed;
            left: 0;
            top: 0;
            pointer-events: none;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            transition: width 0.2s ease, height 0.2s ease, border-color 0.2s ease;
            z-index: 4;
        }

        @keyframes fadeInCanvas {
            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <canvas id="grid-canvas"></canvas>
    <canvas id="three-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    
    <div class="custom-cursor"></div>

    <script>
        const particleCanvas = document.getElementById('particle-canvas');
        const ctx = particleCanvas.getContext('2d', { willReadFrequently: true });
        const gridCanvas = document.getElementById('grid-canvas');
        const gridCtx = gridCanvas.getContext('2d');
        const threeCanvas = document.getElementById('three-canvas');

        const customCursor = document.querySelector('.custom-cursor');

        // --- Configuration ---
        const HERO_TEXT = 'NXL';
        const PARTICLE_CHARS = ['*', '<', '>', '+', '!', '?', '#', '$', '%', '&', '0', '1','N','X','L'];
        const FONT_FAMILY = '"Roboto Mono", monospace';
        const BASE_COLOR = '#FFFFFF';
        const HOVER_COLOR = '#FFFFFF';
        const SHADOW_COLOR = '#444444';
        
        let particles = [];
        let mouse = {
            x: null,
            y: null,
            radius: 100
        };
        let breathingCounter = 0;

        // --- Logo Animation Variables ---
        let logos = [];
        let logoSpawnTimer = 0;
        let logoSpawnInterval = 180;
        const logoImages = [];
        const logoData = [
            {
                svg: `<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="0.300781" width="14" height="14" rx="4" fill="#2F2F2F"/><g clip-path="url(#clip0_439_361)"><path d="M3.72266 5.73279V8.8688C3.72266 9.0704 3.82826 9.2528 4.00426 9.3552L6.72106 10.9232C6.89386 11.0224 7.10826 11.0224 7.28106 10.9232L9.99787 9.3552C10.1707 9.256 10.2795 9.0704 10.2795 8.8688V5.73279C10.2795 5.53119 10.1739 5.34879 9.99787 5.24639L7.28106 3.67839C7.10826 3.57919 6.89386 3.57919 6.72106 3.67839L4.00426 5.24639C3.83146 5.34559 3.72586 5.53119 3.72586 5.73279H3.72266Z" fill="#2F2F2F"/><path d="M7.59264 7.90879L7.20544 8.97119C7.19584 8.99999 7.19584 9.03199 7.20544 9.06399L7.87104 10.8912L8.64225 10.4464L7.71744 7.90879C7.69504 7.85119 7.61504 7.85119 7.59264 7.90879Z" fill="#12AAFF"/><path d="M8.36979 6.12319C8.34739 6.06559 8.26739 6.06559 8.24499 6.12319L7.85779 7.18559C7.84819 7.21439 7.84819 7.24639 7.85779 7.27839L8.94899 10.2704L9.72019 9.82559L8.36979 6.12639V6.12319Z" fill="#12AAFF"/><path d="M6.99971 3.79678C7.01891 3.79678 7.03811 3.80318 7.05411 3.81278L9.99171 5.50879C10.0269 5.52799 10.0461 5.56639 10.0461 5.60479V8.99679C10.0461 9.03519 10.0237 9.07359 9.99171 9.09279L7.05411 10.7888C7.03811 10.7984 7.01891 10.8048 6.99971 10.8048C6.98051 10.8048 6.96131 10.7984 6.94531 10.7888L4.0077 9.09279C3.9725 9.07359 3.9533 9.03519 3.9533 8.99679V5.60159C3.9533 5.56319 3.9757 5.52479 4.0077 5.50559L6.94531 3.80958C6.96131 3.79998 6.98051 3.79358 6.99971 3.79358V3.79678ZM6.99971 3.30078C6.89411 3.30078 6.79171 3.32638 6.69571 3.38078L3.7581 5.07678C3.5693 5.18558 3.4541 5.38399 3.4541 5.60159V8.99359C3.4541 9.21119 3.5693 9.40959 3.7581 9.51839L6.69571 11.2144C6.78851 11.2688 6.89411 11.2944 6.99971 11.2944C7.10531 11.2944 7.20771 11.2688 7.30371 11.2144L10.2413 9.51839C10.4301 9.40959 10.5453 9.21119 10.5453 8.99359V5.60159C10.5453 5.38399 10.4301 5.18558 10.2413 5.07678L7.30051 3.38078C7.20771 3.32638 7.10211 3.30078 6.99651 3.30078H6.99971Z" fill="#9DCCED"/><path d="M5.05371 10.2736L5.32571 9.53119L5.86971 9.98239L5.36091 10.4496L5.05371 10.2736Z" fill="#213147"/><path d="M6.74943 5.36158H6.00383C5.94943 5.36158 5.89823 5.39678 5.87903 5.44798L4.28223 9.82559L5.05343 10.2704L6.81343 5.44798C6.82943 5.40318 6.79743 5.35838 6.75263 5.35838L6.74943 5.36158Z" fill="white"/><path d="M8.05524 5.36158H7.30964C7.25524 5.36158 7.20404 5.39678 7.18484 5.44798L5.36084 10.4464L6.13204 10.8912L8.11604 5.44798C8.13204 5.40318 8.10004 5.35838 8.05524 5.35838V5.36158Z" fill="white"/></g><defs><clipPath id="clip0_439_361"><rect width="8.00002" height="8.00002" fill="white" transform="translate(3 3.30078)"/></clipPath></defs></svg>`,
                color: '#12AAFF'
            },
            {
                svg: `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="14" height="14" rx="3.8" fill="#2F2F2F"/><path fill-rule="evenodd" clip-rule="evenodd" d="M5.31544 10H4.17799C3.93897 10 3.82091 10 3.74892 9.954C3.67117 9.9036 3.62366 9.82012 3.6179 9.72806C3.61358 9.64319 3.67261 9.53956 3.79068 9.33233L6.59919 4.38525C6.71869 4.17518 6.77917 4.07014 6.85546 4.03129C6.93754 3.98957 7.03544 3.98957 7.11753 4.03129C7.19382 4.07014 7.25429 4.17518 7.3738 4.38525L7.95117 5.39245L7.95411 5.39759C8.08318 5.62296 8.14867 5.73725 8.17725 5.8572C8.20889 5.98814 8.20889 6.12627 8.17725 6.25721C8.14846 6.37807 8.08364 6.49318 7.95261 6.72194L6.47736 9.32804L6.47358 9.33471C6.34364 9.56194 6.27779 9.6771 6.18656 9.76399C6.08721 9.85899 5.96768 9.928 5.83666 9.96692C5.71715 10 5.58325 10 5.31544 10ZM8.1879 10H9.81771C10.0582 10 10.1792 10 10.2512 9.9526C10.3289 9.9022 10.3779 9.81728 10.3822 9.72522C10.3863 9.64309 10.3286 9.54354 10.2155 9.34836C10.2115 9.34169 10.2076 9.33497 10.2037 9.3281L9.38724 7.93239L9.37794 7.91668C9.26324 7.72279 9.20535 7.62489 9.13097 7.58706C9.04894 7.54534 8.95238 7.54534 8.87035 7.58706C8.79551 7.62593 8.73503 7.72806 8.61552 7.93384L7.80204 9.32949L7.79925 9.3343C7.68016 9.53976 7.62061 9.64242 7.6249 9.72662C7.63069 9.81873 7.6782 9.9036 7.75594 9.954C7.82649 10 7.94744 10 8.1879 10Z" fill="#E84142"/></svg>`,
                color: '#E84142'
            },
            {
                svg: `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.2667 0H3.73333C1.67147 0 0 1.67147 0 3.73333V10.2667C0 12.3285 1.67147 14 3.73333 14H10.2667C12.3285 14 14 12.3285 14 10.2667V3.73333C14 1.67147 12.3285 0 10.2667 0Z" fill="#2F2F2F"/><path d="M9.02249 5.9325C8.95846 5.26386 8.38187 5.03956 7.6526 4.97121V4.05051H7.08883V4.95412C6.94042 4.95412 6.7888 4.95412 6.63824 4.95412V4.05051H6.07875V4.97761H4.9352V5.58109C4.9352 5.58109 5.35162 5.57361 5.34521 5.58109C5.42029 5.57283 5.49565 5.59405 5.55541 5.64027C5.61516 5.68649 5.65464 5.75412 5.66553 5.82889V8.3667C5.66393 8.39307 5.65706 8.41885 5.64532 8.44252C5.63358 8.46618 5.61722 8.48725 5.5972 8.50448C5.57755 8.52204 5.55456 8.53544 5.52961 8.54388C5.50465 8.55233 5.47825 8.55564 5.45198 8.55362C5.45946 8.56002 5.04197 8.55362 5.04197 8.55362L4.9352 9.22762H6.06807V10.1697H6.63184V9.24148H7.08243V10.1654H7.64726V9.23398C8.59969 9.17628 9.26379 8.94134 9.34713 8.04947C9.41434 7.3317 9.07699 7.01128 8.53776 6.88204C8.86559 6.72076 9.06844 6.42169 9.02249 5.9325ZM8.23238 7.93839C8.23238 8.63909 7.03224 8.55895 6.64999 8.55895V7.31568C7.03224 7.31675 8.23238 7.20673 8.23238 7.93839ZM7.97079 6.1867C7.97079 6.82756 6.96924 6.7496 6.65106 6.7496V5.61954C6.96924 5.61954 7.97079 5.51914 7.97079 6.1867Z" fill="#F09242"/></svg>`,
                color: '#F09242'
            },
            {
                svg: `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.2667 0H3.73333C1.67147 0 0 1.67147 0 3.73333V10.2667C0 12.3285 1.67147 14 3.73333 14H10.2667C12.3285 14 14 12.3285 14 10.2667V3.73333C14 1.67147 12.3285 0 10.2667 0Z" fill="#2F2F2F"/><path d="M6.99603 3V5.95718L9.66183 7.07413L6.99603 3Z" fill="white" fill-opacity="0.602"/><path d="M6.99603 3L4.33008 7.07412L6.99603 5.95718V3Z" fill="white"/><path d="M6.99603 8.99059V11L9.66341 7.53975L6.99603 8.99059Z" fill="white" fill-opacity="0.602"/><path d="M6.99603 11V8.99059L4.33008 7.53975L6.99603 11Z" fill="white"/><path d="M6.99603 8.52515L9.66183 7.07413L6.99603 5.95718V8.52515Z" fill="white" fill-opacity="0.2"/><path d="M4.33008 7.07412L6.99603 8.52515V5.95718L4.33008 7.07412Z" fill="white" fill-opacity="0.602"/></svg>`,
                color: '#FFFFFF'
            }
        ];

        function setCanvasSize() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            gridCanvas.width = window.innerWidth;
            gridCanvas.height = window.innerHeight;
            threeCanvas.width = window.innerWidth;
            threeCanvas.height = window.innerHeight;
        }

        class Particle {
            constructor(x, y, char, color, size) {
                this.originX = x; this.originY = y;
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.char = char; this.baseColor = color; this.color = color;
                this.baseSize = size; this.size = size;
                this.vx = 0; this.vy = 0;
                this.density = (Math.random() * 3) + 25;
                this.ease = 0.005;
                this.frameCount = 0;
                this.changeInterval = Math.floor(Math.random() * 100 + 10);
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px ${FONT_FAMILY}`;
                ctx.fillText(this.char, this.x, this.y);
            }
            update() {
                this.frameCount++;
                if (this.frameCount % this.changeInterval === 0) { this.char = PARTICLE_CHARS[Math.floor(Math.random() * PARTICLE_CHARS.length)]; }
                let dx = mouse.x - this.x, dy = mouse.y - this.y, distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < mouse.radius) {
                    const forceDirectionX = dx / distance, forceDirectionY = dy / distance;
                    const force = (mouse.radius - distance) / mouse.radius;
                    const directionX = forceDirectionX * force * this.density, directionY = forceDirectionY * force * this.density;
                    this.vx -= directionX; this.vy -= directionY;
                    this.color = HOVER_COLOR; this.size = this.baseSize;
                } else {
                    const breath = Math.sin(breathingCounter + this.originY * 0.05);
                    const targetX = this.originX + breath * 2.5, targetY = this.originY + breath * 2.5;
                    this.size = this.baseSize + breath * 1;
                    this.vx += (targetX - this.x) * this.ease; this.vy += (targetY - this.y) * this.ease;
                    this.color = this.baseColor;
                }
                const friction = distance < mouse.radius ? 0.96 : 0.90;
                this.vx *= friction; this.vy *= friction;
                this.x += this.vx; this.y += this.vy;
            }
        }
        
        class LogoParticle {
            constructor(x, y, parentLogo, color) {
                this.parentLogo = parentLogo;
                this.originX = x - parentLogo.x;
                this.originY = y - parentLogo.y;
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = (Math.random() - 0.5) * 20;
                this.alpha = 1;
                this.size = Math.random() * 0.5 + 0.1;
                this.color = color;
                this.ease = 0.06;
                this.density = (Math.random() * 1) + 0;
            }
            draw() {
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            update() {
                let dx = mouse.x - this.x, dy = mouse.y - this.y, distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < mouse.radius) {
                    const forceDirectionX = dx / distance, forceDirectionY = dy / distance;
                    const force = (mouse.radius - distance) / mouse.radius;
                    const directionX = forceDirectionX * force * this.density, directionY = forceDirectionY * force * this.density;
                    this.vx -= directionX; this.vy -= directionY;
                } else {
                    const targetX = this.parentLogo.x + this.originX;
                    const targetY = this.parentLogo.y + this.originY;
                    this.vx += (targetX - this.x) * this.ease;
                    this.vy += (targetY - this.y) * this.ease;
                }
                this.vx *= 0.95; this.vy *= 0.95;
                this.x += this.vx; this.y += this.vy;
            }
        }
        
        class Logo {
            constructor(x, y, data) {
                this.x = x; this.y = y;
                this.image = data.image;
                this.color = data.color;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = (Math.random() - 0.5) * 1;
                this.rotation = 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.size = 32;
                this.alpha = 0;
                this.lifespan = 600;
                this.age = 0;
                this.state = 'fading_in';
                this.particles = [];
            }

            draw() {
                if (this.state === 'dispersed') {
                    this.particles.forEach(p => p.draw());
                } else {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.drawImage(this.image, -this.size / 2, -this.size / 2, this.size, this.size);
                    ctx.restore();
                }
            }

            update() {
                this.age++;
                if (this.state === 'fading_in') {
                    this.alpha = Math.min(1, this.alpha + 0.05);
                    if (this.alpha >= 1) this.state = 'drifting';
                } else if (this.state === 'fading_out') {
                    this.alpha = Math.max(0, this.alpha - 0.05);
                }

                if (this.age > this.lifespan && this.state !== 'dispersed') {
                    this.state = 'fading_out';
                }

                this.x += this.vx; this.y += this.vy;
                this.rotation += this.rotationSpeed;
                if (this.x < this.size/2 || this.x > particleCanvas.width - this.size/2) this.vx *= -1;
                if (this.y < this.size/2 || this.y > particleCanvas.height - this.size/2) this.vy *= -1;
                
                if (this.state === 'dispersed') {
                    this.particles.forEach(p => p.update());
                    const allReformed = this.particles.every(p => {
                        const targetX = this.x + p.originX;
                        const targetY = this.y + p.originY;
                        const dist = Math.sqrt(Math.pow(p.x - targetX, 2) + Math.pow(p.y - targetY, 2));
                        return dist < 1;
                    });
                    if (allReformed) {
                        this.state = 'fading_in';
                        this.particles = [];
                    }
                }
            }

            disperse() {
                if (this.state !== 'drifting') return;
                this.state = 'dispersed';
                this.particles = [];
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.size; tempCanvas.height = this.size;
                tempCtx.drawImage(this.image, 0, 0, this.size, this.size);
                const imageData = tempCtx.getImageData(0, 0, this.size, this.size);
                const gap = 2; // Denser particles for a bigger burst
                for (let y = 0; y < imageData.height; y += gap) {
                    for (let x = 0; x < imageData.width; x += gap) {
                        if (imageData.data[(y * 4 * imageData.width) + (x * 4) + 3] > 128) {
                            this.particles.push(new LogoParticle(this.x - this.size/2 + x, this.y - this.size/2 + y, this, this.color));
                        }
                    }
                }
            }
        }
        
        function initParticles() {
            if (particleCanvas.width <= 0 || particleCanvas.height <= 0) return;
            const mainParticles = [], shadowParticles = [];
            const fontSize = Math.min(particleCanvas.width / 2.5, 580);
            ctx.font = `bold ${fontSize}px ${FONT_FAMILY}`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const metricsN = ctx.measureText('N'), metricsL = ctx.measureText('L');
            const horizontalShift = (metricsL.width - metricsN.width) / 2;
            const shadowOffsetX = 5, shadowOffsetY = 5;
            const rightShift = 50, verticalShift = 0;
            const textX = (particleCanvas.width / 2) - horizontalShift - (shadowOffsetX / 2) + rightShift;
            const textY = (particleCanvas.height / 2) - (shadowOffsetY / 2) + verticalShift;
            ctx.fillText(HERO_TEXT, textX, textY);
            const textCoordinates = ctx.getImageData(0, 0, particleCanvas.width, particleCanvas.height);
            ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            const gap = 6;
            for (let y = 0; y < textCoordinates.height; y += gap) {
                for (let x = 0; x < textCoordinates.width; x += gap) {
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128) {
                        const randomChar = PARTICLE_CHARS[Math.floor(Math.random() * PARTICLE_CHARS.length)];
                        mainParticles.push(new Particle(x, y, randomChar, BASE_COLOR, 8));
                        shadowParticles.push(new Particle(x + shadowOffsetX, y + shadowOffsetY, randomChar, SHADOW_COLOR, 8));
                    }
                }
            }
            particles = [...shadowParticles, ...mainParticles];
        }

        function animateParticles() {
            ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            breathingCounter += 0.1;
            particles.forEach(p => { p.update(); p.draw(); });

            logoSpawnTimer++;
            if (logoSpawnTimer > logoSpawnInterval && logos.length < 5) {
                const randomX = Math.random() * particleCanvas.width;
                const randomY = Math.random() * particleCanvas.height;
                const randomLogoData = logoImages[Math.floor(Math.random() * logoImages.length)];
                logos.push(new Logo(randomX, randomY, randomLogoData));
                logoSpawnTimer = 0;
            }

            logos.forEach((logo, index) => {
                let dx = mouse.x - logo.x, dy = mouse.y - logo.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < logo.size / 2) {
                    logo.disperse();
                }
                logo.update();
                logo.draw();
                if (logo.alpha <= 0 && logo.state === 'fading_out') {
                    logos.splice(index, 1);
                }
            });

            requestAnimationFrame(animateParticles);
        }

        function drawGridLines() {
            const gridSize = 30;
            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            gridCtx.lineWidth = 1;
            for (let x = gridSize; x < gridCanvas.width; x += gridSize) {
                gridCtx.beginPath(); gridCtx.moveTo(x, 0); gridCtx.lineTo(x, gridCanvas.height); gridCtx.stroke();
            }
            for (let y = gridSize; y < gridCanvas.height; y += gridSize) {
                gridCtx.beginPath(); gridCtx.moveTo(0, y); gridCtx.lineTo(gridCanvas.width, y); gridCtx.stroke();
            }
        }

        function animateGrid() {
            return new Promise((resolve) => {
                const duration = 2000; let startTime = null;
                function draw(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = Math.min((timestamp - startTime) / duration, 1);
                    gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                    gridCtx.save();
                    gridCtx.beginPath();
                    const diagLength = (gridCanvas.width + gridCanvas.height) * progress * 0.5;
                    gridCtx.moveTo(0, 0); gridCtx.lineTo(diagLength, 0); gridCtx.lineTo(0, diagLength); gridCtx.closePath();
                    const w = gridCanvas.width, h = gridCanvas.height;
                    gridCtx.moveTo(w, h); gridCtx.lineTo(w - diagLength, h); gridCtx.lineTo(w, h - diagLength); gridCtx.closePath();
                    gridCtx.clip();
                    drawGridLines();
                    gridCtx.restore();
                    if (progress < 1) { requestAnimationFrame(draw); } else {
                        gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                        drawGridLines();
                        resolve();
                    }
                }
                requestAnimationFrame(draw);
            });
        }

        // --- NEW: Three.js Animation ---
        let scene, camera, renderer, threeParticles, originalPositions;
        let threeMouse = new THREE.Vector2(-100, -100);

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300;
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const numParticles = 10000;
            const radius = 150;

            for (let i = 0; i < numParticles; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            originalPositions = geometry.attributes.position.clone();

            const material = new THREE.PointsMaterial({
                color: 0x444444,
                size: 1.5,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });

            threeParticles = new THREE.Points(geometry, material);
            scene.add(threeParticles);
        }

        function animateThreeJS() {
            const positions = threeParticles.geometry.attributes.position.array;
            const time = Date.now() * 0.0005;

            for (let i = 0; i < positions.length; i += 3) {
                const ox = originalPositions.array[i];
                const oy = originalPositions.array[i + 1];
                const oz = originalPositions.array[i + 2];

                const vertex = new THREE.Vector3(ox, oy, oz);
                const mouseVec = new THREE.Vector3(threeMouse.x * 200, threeMouse.y * 200, 0);
                const dist = vertex.distanceTo(mouseVec);
                
                let repulsion = 0;
                if (dist < 100) {
                    repulsion = (100 - dist) * 0.5;
                }

                positions[i] = ox + Math.sin(time + ox * 0.01) * 5 + repulsion * (ox - mouseVec.x) * 0.01;
                positions[i+1] = oy + Math.cos(time + oy * 0.01) * 5 + repulsion * (oy - mouseVec.y) * 0.01;
                positions[i+2] = oz + Math.sin(time + oz * 0.01) * 5;
            }
            
            threeParticles.geometry.attributes.position.needsUpdate = true;
            threeParticles.rotation.y += 0.0005;
            renderer.render(scene, camera);
            requestAnimationFrame(animateThreeJS);
        }

        window.addEventListener('mousemove', (event) => {
            mouse.x = event.clientX; mouse.y = event.clientY;
            threeMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            threeMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (customCursor) { customCursor.style.left = `${event.clientX}px`; customCursor.style.top = `${event.clientY}px`; }
        });
        window.addEventListener('mouseout', () => { mouse.x = null; mouse.y = null; });
        window.addEventListener('resize', () => { 
            setCanvasSize(); 
            initParticles(); 
            gridCtx.clearRect(0,0,gridCanvas.width, gridCanvas.height); 
            drawGridLines(); 
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        async function main() {
            setCanvasSize();
            let loadedCount = 0;
            logoData.forEach(data => {
                const img = new Image();
                img.onload = () => {
                    loadedCount++;
                    logoImages.push({ image: img, color: data.color });
                    if (loadedCount === logoData.length) {
                        startAnimations();
                    }
                };
                img.src = `data:image/svg+xml;base64,${btoa(data.svg)}`;
            });
        }

        async function startAnimations() {
            await animateGrid();
            
            // Start the 3D animation and the 2D animation concurrently
            initThreeJS();
            animateThreeJS();

            initParticles();
            animateParticles();
        }

        main();

    </script>
</body>
</html>
